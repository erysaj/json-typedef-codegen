use jtd_codegen::target::{self, inflect, metadata};
use jtd_codegen::Result;
use lazy_static::lazy_static;
use std::collections::{BTreeSet};
use std::io::Write;

lazy_static! {
    static ref KEYWORDS: BTreeSet<String> = include_str!("keywords")
        .lines()
        .map(str::to_owned)
        .collect();
    static ref TYPE_NAMING_CONVENTION: Box<dyn inflect::Inflector + Send + Sync> =
        Box::new(inflect::KeywordAvoidingInflector::new(
            KEYWORDS.clone(),
            inflect::CombiningInflector::new(inflect::Case::pascal_case())
        ));
    static ref FIELD_NAMING_CONVENTION: Box<dyn inflect::Inflector + Send + Sync> =
        Box::new(inflect::KeywordAvoidingInflector::new(
            KEYWORDS.clone(),
            inflect::TailInflector::new(inflect::Case::camel_case())
        ));
    static ref ENUM_MEMBER_NAMING_CONVENTION: Box<dyn inflect::Inflector + Send + Sync> =
        Box::new(inflect::KeywordAvoidingInflector::new(
            KEYWORDS.clone(),
            inflect::TailInflector::new(inflect::Case::camel_case())
        ));
}

pub struct Target {}

impl Target {
    pub fn new() -> Self {
        Self {}
    }
}

impl jtd_codegen::target::Target for Target {
    type FileState = FileState;

    fn strategy(&self) -> target::Strategy {
        target::Strategy {
            file_partitioning: target::FilePartitioningStrategy::FilePerType("swift".into()),
            enum_member_naming: target::EnumMemberNamingStrategy::Modularized,
            optional_property_handling: target::OptionalPropertyHandlingStrategy::WrapWithNullable,
            booleans_are_nullable: false,
            int8s_are_nullable: false,
            uint8s_are_nullable: false,
            int16s_are_nullable: false,
            uint16s_are_nullable: false,
            int32s_are_nullable: false,
            uint32s_are_nullable: false,
            float32s_are_nullable: false,
            float64s_are_nullable: false,
            strings_are_nullable: false,
            timestamps_are_nullable: false,
            arrays_are_nullable: false,
            dicts_are_nullable: false,
            aliases_are_nullable: false,
            enums_are_nullable: false,
            structs_are_nullable: false,
            discriminators_are_nullable: false,
        }
    }

    fn name(&self, kind: target::NameableKind, parts: &[String]) -> String {
        match kind {
            target::NameableKind::Type => TYPE_NAMING_CONVENTION.inflect(parts),
            target::NameableKind::Field => FIELD_NAMING_CONVENTION.inflect(parts),
            target::NameableKind::EnumMember => ENUM_MEMBER_NAMING_CONVENTION.inflect(parts),
        }
    }

    fn expr(
        &self,
        _state: &mut FileState,
        metadata: metadata::Metadata,
        expr: target::Expr,
    ) -> String {
        if let Some(s) = metadata.get("swiftType").and_then(|v| v.as_str()) {
            return s.into();
        }

        match expr {
            target::Expr::Empty => {
                "Any".into()
            }
            target::Expr::Boolean => "Bool".into(),
            target::Expr::Int8 => "Int8".into(),
            target::Expr::Uint8 => "UInt8".into(),
            target::Expr::Int16 => "Int16".into(),
            target::Expr::Uint16 => "UInt16".into(),
            target::Expr::Int32 => "Int32".into(),
            target::Expr::Uint32 => "UInt32".into(),
            target::Expr::Float32 => "Float".into(),
            target::Expr::Float64 => "Double".into(),
            target::Expr::String => "String".into(),
            // TODO: generate implementation
            target::Expr::Timestamp => "Timestamp".into(),
            target::Expr::ArrayOf(sub_expr) => format!("[{}]", sub_expr),
            target::Expr::DictOf(sub_expr) => format!("[String: {}]", sub_expr),
            target::Expr::NullableOf(sub_expr) => format!("{}?", sub_expr),
        }
    }

    fn item(
        &self,
        out: &mut dyn Write,
        _state: &mut FileState,
        item: target::Item,
    ) -> Result<Option<String>> {
        Ok(match item {
            target::Item::Auxiliary { .. } => {
                // TODO: implement Timestamp support
                None
            }

            target::Item::Preamble => {
                writeln!(
                    out,
                    "// Code generated by jtd-codegen for Swift v{}",
                    env!("CARGO_PKG_VERSION")
                )?;

                writeln!(out)?;
                writeln!(out, "import Foundation")?;
                None
            }

            target::Item::Postamble => None,

            target::Item::Alias {
                metadata,
                name,
                type_,
            } => {
                writeln!(out)?;
                write!(out, "{}", description(&metadata, 0))?;
                writeln!(out, "typealias {} = {}", name, type_)?;

                None
            }

            target::Item::Enum {
                metadata,
                name,
                members,
            } => {
                if let Some(s) = metadata.get("swiftType").and_then(|v| v.as_str()) {
                    return Ok(Some(s.into()));
                }

                write!(out, "{}", enum_implementation(&metadata, &name, &members))?;
                None
            }

            target::Item::Struct {
                metadata,
                name,
                has_additional: _,
                fields,
            } => {
                if let Some(s) = metadata.get("swiftType").and_then(|v| v.as_str()) {
                    return Ok(Some(s.into()));
                }

                write!(out, "{}", struct_implementation(&metadata, &name, &fields))?;
                None
            }

            target::Item::Discriminator {
                metadata,
                name,
                tag_field_name,
                tag_json_name,
                variants,
            } => {
                if let Some(s) = metadata.get("swiftType").and_then(|v| v.as_str()) {
                    return Ok(Some(s.into()));
                }

                write!(out, "{}", enum_with_associated_data_implementation(&metadata, &name, &tag_field_name, &tag_json_name, &variants))?;
                None
            }

            target::Item::DiscriminatorVariant {
                metadata,
                name,
                fields,
                ..
            } => {
                if let Some(s) = metadata.get("swiftType").and_then(|v| v.as_str()) {
                    return Ok(Some(s.into()));
                }

                write!(out, "{}", struct_implementation(&metadata, &name, &fields))?;
                None
            }
        })
    }
}

#[derive(Default)]
pub struct FileState {}

fn doc(indent: usize, s: &str) -> String {
    let prefix = "    ".repeat(indent);
    target::fmt::comment_block("", &format!("{}/// ", prefix), "", s)
}

fn description(metadata: &metadata::Metadata, indent: usize) -> String {
    doc(indent, metadata::description(metadata))
}

fn enum_variant_description(
    metadata: &metadata::Metadata,
    indent: usize,
    value: &str,
) -> String {
    doc(indent, metadata::enum_variant_description(metadata, value))
}

fn enum_implementation(
    metadata: &metadata::Metadata,
    name: &str,
    members: &Vec<target::EnumMember>,
) -> String {
    let mut chunks: Vec<String> = vec![];

    chunks.push(format!("\n"));
    chunks.push(description(&metadata, 0));
    chunks.push(format!("public enum {}: String, Codable {{\n", name));

    for (index, member) in members.iter().enumerate() {
        if index != 0 {
            chunks.push(format!("\n"));
        }

        chunks.push(enum_variant_description(&metadata, 1, &member.json_value));
        chunks.push(format!("    case {} = \"{}\"\n", member.name, member.json_value));
    }
    chunks.push(format!("}}\n"));

    chunks.join("")
}

fn struct_implementation(
    metadata: &metadata::Metadata,
    name: &str,
    fields: &Vec<target::Field>
) -> String {
    let mut chunks: Vec<String> = vec![];

    chunks.push(format!("\n"));
    chunks.push(description(&metadata, 0));

    if fields.is_empty() {
        chunks.push(format!("public struct {}: Codable {{}}\n", name));
    } else {
        chunks.push(format!("public struct {}: Codable {{\n", name));
        for (index, field) in fields.iter().enumerate() {
            if index != 0 {
                chunks.push(format!("\n"));
            }

            chunks.push(description(&field.metadata, 1));
            // if field.optional {
            //     writeln!(
            //         out,
            //         "    #[serde(skip_serializing_if = \"Option::is_none\")]"
            //     )?;
            // }
            chunks.push(format!("    public var {}: {}\n", field.name, field.type_));
        }

        chunks.push(format!("\n"));
        chunks.push(format!("    enum CodingKeys: String, CodingKey {{\n"));
        for field in fields {
            chunks.push(format!("        case {} = \"{}\"\n", field.name, field.json_name));
        }
        chunks.push(format!("    }}\n"));

        // Decodable implementation
        chunks.push(format!("\n"));
        chunks.push(format!("    init(from decoder: Decoder) throws {{\n"));
        chunks.push(format!("        var container = decoder.container(keyedBy: CodingKeys.self)\n"));
        chunks.push(format!("\n"));
        for field in fields {
            chunks.push(format!("        self.{0} = try container.decode({1}.self, forKey: {0})\n", field.name, field.type_));
        }
        chunks.push(format!("    }}\n"));
        
        // Encodable implementation
        chunks.push(format!("\n"));
        chunks.push(format!("    func encode(to encoder: Encoder) throws {{\n"));
        chunks.push(format!("        var container = encoder.container(keyedBy: CodingKeys.self)\n"));
        chunks.push(format!("\n"));
        for field in fields {
            chunks.push(format!("        try container.encode(self.{0}, forKey: {0})\n", field.name));
        }
        chunks.push(format!("    }}\n"));

        chunks.push(format!("}}\n"));
    }

    chunks.join("")
}

fn enum_with_associated_data_implementation(
    metadata: &metadata::Metadata,
    name: &str,
    tag_field_name: &str,
    tag_json_name: &str,
    variants: &Vec<target::DiscriminatorVariantInfo>
) -> String {
    let mut chunks: Vec<String> = vec![];

    chunks.push(format!("\n"));
    chunks.push(description(&metadata, 0));
    chunks.push(format!("public enum {} {{\n", name));
    for variant in variants {
        chunks.push(format!("    case {}({})\n", variant.field_name, variant.type_name));
    }

    chunks.push(format!("\n"));
    chunks.push(format!("    enum Tag: String {{\n"));
    for variant in variants {
        chunks.push(format!("        case {} = \"{}\"\n", variant.field_name, variant.tag_value));
    }
    chunks.push(format!("    }}\n"));

    chunks.push(format!("\n"));
    chunks.push(format!("    enum CodingKeys: String, CodingKey {{\n"));
    chunks.push(format!("        case tag = \"{}\"\n", tag_json_name));
    chunks.push(format!("    }}\n"));

    // Decodable implementation
    chunks.push(format!("\n"));
    chunks.push(format!("    init(from decoder: Decoder) throws {{\n"));
    chunks.push(format!("        var container = decoder.container(keyedBy: CodingKeys.self)\n"));
    chunks.push(format!("\n"));
    chunks.push(format!("        let tag = try container.decode(Tag.self, forKey: .tag)\n"));
    chunks.push(format!("        switch tag {{\n"));
    for variant in variants {
        chunks.push(format!("        case .{}:\n", variant.field_name));
        chunks.push(format!("            let props = try {}(from: decoder)\n", variant.type_name));
        chunks.push(format!("            self = .{}(props)\n", variant.field_name));
    }
    chunks.push(format!("        }}\n"));
    chunks.push(format!("    }}\n"));

    // Encodable implementation
    chunks.push(format!("\n"));
    chunks.push(format!("    func encode(to encoder: Encoder) throws {{\n"));
    chunks.push(format!("        var container = encoder.container(keyedBy: CodingKeys.self)\n"));
    chunks.push(format!("\n"));
    chunks.push(format!("        switch self {{\n"));
    for variant in variants {
        chunks.push(format!("        case let .{}(props):\n", variant.field_name));
        chunks.push(format!("            try props.encode(to: encoder)\n"));
    }
    chunks.push(format!("        }}\n"));
    chunks.push(format!("    }}\n"));

    chunks.push(format!("}}\n"));

    chunks.join("")
}

#[cfg(test)]
mod tests {
    mod std_tests {
        jtd_codegen_test::std_test_cases!(&crate::Target::new());
    }

    // mod optional_std_tests {
    //     jtd_codegen_test::strict_std_test_case!(
    //         &crate::Target::new(),
    //         empty_and_nonascii_properties
    //     );

    //     jtd_codegen_test::strict_std_test_case!(
    //         &crate::Target::new(),
    //         empty_and_nonascii_enum_values
    //     );
    // }
}
